#!/bin/env -S lash run

set -euo pipefail

cd ../..

let PROJECT_NAME = "Lash"

let OUTPUT_DIR = "./target/release"
let PROJECTS = [
    "lash:./src/Lash.Cli/Lash.Cli.csproj",
    "lashc:./src/Lash.Compiler/Lash.Compiler.csproj",
    "lashfmt:./src/Lash.Formatter/Lash.Formatter.csproj",
    "lashlsp:./src/Lash.Lsp/Lash.Lsp.csproj"
]

// Build defaults
const CONFIGURATION = "Release"
let ENABLE_TRIMMING = true
let ENABLE_SINGLE_FILE = true
let ENABLE_READY_TO_RUN = true

// Color output
let RED = "\033[0;31m"
let GREEN = "\033[0;32m"
let YELLOW = "\033[1;33m"
let BLUE = "\033[0;34m"
let NC = "\033[0m"

fn show_help()
    echo "Usage: $0 [OPTIONS] <platform1> [platform2] ..."
    echo ""
    echo "Options:"
    echo "  --no-trim          Disable trimming (faster builds, larger binaries)"
    echo "  --no-single-file   Publish as multiple files (faster builds, easier debugging)"
    echo "  --no-ready2run     Disable ReadyToRun compilation (faster builds, slower startup)"
    echo "  -h, --help         Show this help message"
    echo ""
    echo "Arguments:"
    echo "  <platforms>  Space-separated list of platforms to build"
    echo ""
    echo "Available platforms:"
    echo "  win-x64, win-x86, win-arm64"
    echo "  linux-x64, linux-arm64, linux-arm"
    echo "  osx-x64, osx-arm64"
    echo ""
    echo "Examples:"
    echo "  $0 win-x64                           # Build only Windows 64-bit"
    echo "  $0 --no-trim win-x64                 # Build Windows 64-bit without trimming"
    echo "  $0 --no-single-file --no-trim win-x64  # Fast dev build"
    echo "  $0 win-x64 linux-x64                 # Build Windows and Linux 64-bit"
    echo "  $0 osx-x64 osx-arm64                 # Build both macOS versions"
    exit 0
end

fn is_windows_rid(rid)
    switch rid
        case "win-*":
            return true
    end
    return false
end

fn file_exists(path)
    let exists = $sh $"if [ -f \"{path}\" ]; then echo 1; else echo 0; fi"
    if exists == "1"
        return true
    end
    return false
end

fn dir_exists(path)
    let exists = $sh $"if [ -d \"{path}\" ]; then echo 1; else echo 0; fi"
    if exists == "1"
        return true
    end
    return false
end

fn get_output_dirname(rid)
    let platform = ""
    let arch = ""
    let bits = ""

    switch rid
        case "win-x64":
            platform = "win"
            arch = "x86"
            bits = "64"
        case "win-x86":
            platform = "win"
            arch = "x86"
            bits = "32"
        case "win-arm64":
            platform = "win"
            arch = "arm"
            bits = "64"
        case "linux-x64":
            platform = "linux"
            arch = "x86"
            bits = "64"
        case "linux-arm64":
            platform = "linux"
            arch = "arm"
            bits = "64"
        case "linux-arm":
            platform = "linux"
            arch = "arm"
            bits = "32"
        case "osx-x64":
            platform = "osx"
            arch = "x86"
            bits = "64"
        case "osx-arm64":
            platform = "osx"
            arch = "arm"
            bits = "64"
    end

    return PROJECT_NAME + "-" + platform + "_" + arch + "-" + bits
end

fn find_published_executable(temp_dir, rid, project_stem)
    let src_file = ""

    if is_windows_rid(rid)
        let expected = temp_dir + "/" + project_stem + ".exe"
        if file_exists(expected)
            src_file = expected
        else
            src_file = $sh $"find \"{temp_dir}\" -maxdepth 1 -type f -name '*.exe' ! -name 'createdump.exe' -print -quit"
        end
        return src_file
    end

    let expected = temp_dir + "/" + project_stem
    if file_exists(expected)
        src_file = expected
    else
        src_file = $sh $"find \"{temp_dir}\" -maxdepth 1 -type f -perm -u+x -print -quit"
    end
    return src_file
end

fn build_tool_for_platform(tool_name, project_path, rid, bundle_dir)
    let temp_dir = OUTPUT_DIR + "/temp_" + tool_name + "_" + rid
    let publish_args = [
        project_path,
        "-c",
        CONFIGURATION,
        "-r",
        rid,
        "--self-contained",
        "-p:UseAppHost=true",
        "-o",
        temp_dir
    ]

    if ENABLE_SINGLE_FILE
        publish_args += ["-p:PublishSingleFile=True"]
    end

    if ENABLE_READY_TO_RUN
        publish_args += ["-p:PublishReadyToRun=True"]
    end

    if ENABLE_TRIMMING
        publish_args += [
            "-p:PublishTrimmed=True",
            "-p:TrimMode=CopyUsed",
            "-p:EnableTrimAnalyzer=True",
            "-warnaserror:IL2*"
        ]
    end

    dotnet publish "${publish_args[@]}"

    let project_stem = $sh $"basename \"{project_path}\" .csproj"
    let src_file = find_published_executable(temp_dir, rid, project_stem)

    if src_file == "" || !file_exists(src_file)
        echo -e "${RED}✗ Build completed but executable not found for ${tool_name}${NC}"
        rm -rf "$temp_dir"
        return 1
    end

    let extension = ""
    if is_windows_rid(rid)
        extension = ".exe"
    end

    let dest_file = bundle_dir + "/" + tool_name + extension
    mv "$src_file" "$dest_file"
    rm -rf "$temp_dir"

    if !is_windows_rid(rid)
        chmod +x "$dest_file"
    end

    let size = $sh $"du -h \"{dest_file}\" | cut -f1"
    echo -e "${GREEN}✓ Built ${tool_name} (${size}) -> ${dest_file}${NC}"
end

fn build_platform(rid, description)
    let bundle_dir = OUTPUT_DIR + "/" + get_output_dirname(rid)

    echo ""
    echo -e "${YELLOW}Building for $description ($rid)...${NC}"

    rm -rf "$bundle_dir"
    mkdir -p "$bundle_dir"

    for entry in PROJECTS
        let tool_name = $sh $"printf '%s' \"{entry}\" | cut -d: -f1"
        let project_path = $sh $"printf '%s' \"{entry}\" | cut -d: -f2-"
        build_tool_for_platform(tool_name, project_path, rid, bundle_dir)
    end

    let bundle_size = $sh $"du -sh \"{bundle_dir}\" | cut -f1"
    echo -e "${GREEN}✓ Bundle ready (${bundle_size}) -> ${bundle_dir}${NC}"
    ls -lah "$bundle_dir"
end

fn get_platform_description(rid)
    switch rid
        case "win-x64":
            return "Windows (64-bit)"
        case "win-x86":
            return "Windows (32-bit)"
        case "win-arm64":
            return "Windows ARM64"
        case "linux-x64":
            return "Linux (64-bit)"
        case "linux-arm64":
            return "Linux ARM64"
        case "linux-arm":
            return "Linux ARM"
        case "osx-x64":
            return "macOS Intel"
        case "osx-arm64":
            return "macOS Apple Silicon"
    end

    return rid
end

// Parse options
let BUILD_PLATFORMS = []
while #argv > 0
    let arg = argv[0]

    if arg == "-h" || arg == "--help"
        show_help()
    elif arg == "--no-trim"
        ENABLE_TRIMMING = false
        shift
    elif arg == "--no-single-file"
        ENABLE_SINGLE_FILE = false
        shift
    elif arg == "--no-ready2run"
        ENABLE_READY_TO_RUN = false
        shift
    else
        BUILD_PLATFORMS += [arg]
        shift
    end
end

if #BUILD_PLATFORMS == 0
    echo -e "${RED}Error: No platforms specified${NC}"
    echo ""
    show_help()
end

echo -e "${GREEN}  Building ${PROJECT_NAME}${NC}"
echo -e "${BLUE}Configuration:${NC}"
if ENABLE_TRIMMING
    echo -e "  Trimming:     ${GREEN}Enabled${NC}"
else
    echo -e "  Trimming:     ${YELLOW}Disabled${NC}"
end
if ENABLE_SINGLE_FILE
    echo -e "  Single File:  ${GREEN}Enabled${NC}"
else
    echo -e "  Single File:  ${YELLOW}Disabled${NC}"
end
if ENABLE_READY_TO_RUN
    echo -e "  ReadyToRun:   ${GREEN}Enabled${NC}"
else
    echo -e "  ReadyToRun:   ${YELLOW}Disabled${NC}"
end

if dir_exists(OUTPUT_DIR)
    echo -e "${YELLOW}Cleaning output directory...${NC}"
    rm -rf "$OUTPUT_DIR"
end
mkdir -p "$OUTPUT_DIR"

echo -e "${BLUE}Building platforms: ${BUILD_PLATFORMS[*]}${NC}"
for rid in BUILD_PLATFORMS
    let description = get_platform_description(rid)
    build_platform(rid, description)
end

echo ""
echo -e "${GREEN}========================================${NC}"
echo -e "${GREEN}  Build Complete!${NC}"
echo -e "${GREEN}========================================${NC}"
echo ""
echo "Bundles are located in:"
echo ""
find "$OUTPUT_DIR" -maxdepth 1 -mindepth 1 -type d -name "${PROJECT_NAME}-*" | sort
